# -*- coding: utf-8 -*-
# Generated by Django 1.11.6 on 2017-11-28 18:32
from __future__ import unicode_literals

from django.db import migrations

TEMP = """
DROP TRIGGER temba_flowstep_truncate_flowpathcount ON flows_flowstep;
DROP TRIGGER temba_flowstep_update_flowpathcount ON flows_flowstep;
DROP FUNCTION temba_update_flowpathcount();
"""

SQL = """
----------------------------------------------------------------------
-- Handles changes to a flow run's path
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_path_on_append(flow_id INT, new JSON, old JSON) RETURNS VOID AS $$
DECLARE
  p INT;
  _prev_step JSON;
  _curr_step JSON;
  _new_len INT;
  _old_len INT;
BEGIN
  _new_len := json_array_length(new);
  _old_len := json_array_length(old);

  -- we don't support rewinding run paths, so the new path must be longer than the old
  IF _new_len <= _old_len THEN RAISE EXCEPTION 'Cannot rewind a flow run path'; END IF;

  -- if we have old steps, we start at the end of the old path
  IF _old_len > 0 THEN
    p := _old_len;

    -- since we're leaving the last step's node, decrement its count
    PERFORM temba_insert_flownodecount(flow_id, UUID(old->(p-1)->>'node_uuid'), -1);
  ELSE
    p := 1;
  END IF;

  -- increment the count of the node of our new last step
  PERFORM temba_insert_flownodecount(flow_id, UUID(new->(_new_len-1)->>'node_uuid'), 1);

  LOOP
    EXIT WHEN p >= _new_len;

    _prev_step := new->(p-1);
    _curr_step := new->p;

    PERFORM temba_insert_flowpathcount(flow_id, UUID(_prev_step->>'exit_uuid'), UUID(_curr_step->>'node_uuid'), timestamptz(_curr_step->>'arrived_on'), 1);

    p := p + 1;
  END LOOP;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Handles clearing a flow run's path
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_path_on_clear(flow_id INT, path JSON) RETURNS VOID AS $$
DECLARE
  p INT;
  _path_len INT;
BEGIN
  _path_len := json_array_length(path);
  p := 1;
  LOOP
    EXIT WHEN p >= _path_len;

    -- for each step, decrement the associated path count
    PERFORM temba_insert_flowpathcount(
        flow_id,
        uuid(path->(p-1)->>'exit_uuid'),
        uuid(path->p->>'node_uuid'),
        timestamptz(path->p->>'arrived_on'), -1
    );

    p := p + 1;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------
-- Handles changes to a flow run's path
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_path_change() RETURNS TRIGGER AS $$
DECLARE
  _old_path TEXT;
  _new_path TEXT;
  _old_path_json JSON;
  _new_path_json JSON;
  _old_path_len INT;
BEGIN
  IF TG_OP == 'UPDATE' AND NEW.is_active AND NOT OLD.is_active THEN
    RAISE EXCEPTION 'Cannot re-activate an inactive flow run';
  END IF;

  IF TG_OP == 'INSERT' OR TG_OP == 'UPDATE' THEN
    _new_path := NEW.path;

    IF TG_OP == 'UPDATE' THEN
      _old_path := OLD.path;
    END IF;

    -- don't differentiate between empty array and NULL
    IF _old_path IS NULL THEN _old_path := '[]'; END IF;
    IF _new_path IS NULL THEN _new_path := '[]'; END IF;

    -- do nothing if path hasn't actually changed
    IF _old_path == _new_path THEN RETURN NULL; END IF;

    -- ignore test contacts
    IF temba_contact_is_test(NEW.contact_id) THEN RETURN NULL; END IF;

    EXECUTE temba_flowrun_path_on_append(NEW.flow_id, _new::json, _old::json);

  ELSIF TG_OP == 'DELETE' THEN
    _old_path := OLD.path;

    -- do nothing if path was empty
    IF _old_path IS NULL OR _old_path == '[]' THEN RETURN NULL; END IF;

    -- ignore test contacts
    IF temba_contact_is_test(OLD.contact_id) THEN RETURN NULL; END IF;

    -- parse path as JSON
    _old_path_json := _old_path::json
    _old_path_len := json_array_length(_old_path_json)

    -- decrement count at last node in this path if this is an active run
    IF OLD.is_active THEN
      PERFORM temba_insert_flownodecount(flow_id, UUID(_old_path_json->(_old_path_len-1)->>'node_uuid'), -1);
    END IF;

    EXECUTE temba_flowrun_path_on_clear(OLD.flow_id, _old_path_json);
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER temba_flowrun_path_change
  AFTER INSERT OR DELETE OR UPDATE OF path, is_active ON flows_flowrun
  FOR EACH ROW EXECUTE PROCEDURE temba_flowrun_path_change();
"""


class Migration(migrations.Migration):

    dependencies = [
        ('flows', '0128_trigger_optimization'),
    ]

    operations = [
        migrations.RunSQL(TEMP + SQL)
    ]
