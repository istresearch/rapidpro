from __future__ import print_function, unicode_literals

import regex

from collections import OrderedDict
from django.core.management.base import BaseCommand
from django.db.migrations import RunSQL
from django.db.migrations.loader import MigrationLoader
from django.utils.timezone import now
from enum import Enum
from temba.sql import InstallSQL


class SqlType(Enum):
    INDEX = (
        r'CREATE\s+INDEX\s+(?P<name>\w+)',
        r'DROP\s+INDEX\s+(IF\s+EXISTS)?\s+(?P<name>\w+)'
    )
    FUNCTION = (
        'CREATE\s+(OR\s+REPLACE)?\s+FUNCTION\s+(?P<name>\w+)',
        'DROP\s+FUNCTION\s+(IF\s+EXISTS)?\s+(?P<name>\w+)'
    )
    TRIGGER = (
        'CREATE\s+TRIGGER\s+(?P<name>\w+)',
        'DROP\s+TRIGGER\s+(IF\s+EXISTS)?\s+(?P<name>\w+)'
    )

    def __init__(self, create_pattern, drop_pattern):
        self.create_pattern = create_pattern
        self.drop_pattern = drop_pattern

    @classmethod
    def match(cls, statement):
        for sql_type in cls.__members__.values():
            m = regex.match(sql_type.create_pattern, statement, flags=regex.IGNORECASE)
            if m:
                return sql_type, m.groupdict()['name'], True
            m = regex.match(sql_type.drop_pattern, statement, flags=regex.IGNORECASE)
            if m:
                return sql_type, m.groupdict()['name'], False
        return None


class SqlObjectOperation(object):
    def __init__(self, statement, sql_type, obj_name, is_create):
        self.statement = statement
        self.sql_type = sql_type
        self.obj_name = obj_name
        self.is_create = is_create


class Command(BaseCommand):  # pragma: no cover
    help = "Generates SQL dumps of indexes, functions and triggers based on migrations for a given app"

    def add_arguments(self, parser):
        parser.add_argument('app_label',
                            help='App label of an application to synchronize the state.')

    def handle(self, app_label, *args, **options):
        self.verbosity = options.get('verbosity')

        loader = MigrationLoader(connection=None, load=True)
        migrations = [mig for key, mig in loader.disk_migrations.items() if key[0] == app_label]
        migrations = sorted(migrations, key=lambda m: m.name)

        operations = self.parse_migrations(migrations)

        self.stdout.write("Loaded %d migrations from %s app" % (len(migrations), app_label))

        operations = self.normalize_operations(operations)

        indexes, functions, triggers = [], [], []
        for operation in operations:
            if operation.sql_type == SqlType.INDEX:
                indexes.append(operation)
            elif operation.sql_type == SqlType.FUNCTION:
                functions.append(operation)
            else:
                triggers.append(operation)

        if indexes:
            self.write_dump(app_label, 'indexes', indexes)
        if functions:
            self.write_dump(app_label, 'functions', functions)
        if triggers:
            self.write_dump(app_label, 'triggers', triggers)

    def parse_migrations(self, migrations):
        operations = []

        for migration in migrations:
            for operation in migration.operations:
                if isinstance(operation, RunSQL) and not isinstance(operation, InstallSQL):
                    statements = operation.sql.split(';')

                    for statement in statements:
                        s = statement.strip() + ';'
                        match = SqlType.match(s)
                        if match:
                            operations.append(SqlObjectOperation(s, *match))

        return operations

    def normalize_operations(self, operations):
        normalized = OrderedDict()

        for operation in operations:
            if operation.is_create:
                normalized[operation.obj_name] = operation
            else:
                if operation.obj_name in normalized:
                    del normalized[operation.obj_name]

        return normalized.values()

    def write_dump(self, app_label, type_label, operations):
        filename = 'temba/sql/%s_%s.sql' % (app_label, type_label)

        with open(filename, 'w') as f:
            header = '-- Generated by make_sql on %s\n\n' % now().strftime("%Y-%m-%d %H:%M")
            f.write(header)

            for operation in operations:
                f.write(operation.statement)
                f.write('\n\n')

        self.stdout.write("Saved %s" % filename)
