# Generated by Django 2.1.5 on 2019-02-05 21:26

from django.db import migrations

SQL = """
DROP TRIGGER contact_check_update_trg ON contacts_contact;
DROP FUNCTION contact_check_update();


----------------------------------------------------------------------
-- Trigger procedure to update system labels on broadcast changes
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_broadcast_on_change() RETURNS TRIGGER AS $$
DECLARE
  _new_label_type CHAR(1);
  _old_label_type CHAR(1);
BEGIN
  -- new broadcast inserted
  IF TG_OP = 'INSERT' THEN
    _new_label_type := temba_broadcast_determine_system_label(NEW);
    IF _new_label_type IS NOT NULL THEN
      PERFORM temba_insert_system_label(NEW.org_id, _new_label_type, FALSE, 1);
    END IF;

  -- existing broadcast updated
  ELSIF TG_OP = 'UPDATE' THEN
    _old_label_type := temba_broadcast_determine_system_label(OLD);
    _new_label_type := temba_broadcast_determine_system_label(NEW);

    IF _old_label_type IS DISTINCT FROM _new_label_type THEN
      IF _old_label_type IS NOT NULL THEN
        PERFORM temba_insert_system_label(OLD.org_id, _old_label_type, FALSE, -1);
      END IF;
      IF _new_label_type IS NOT NULL THEN
        PERFORM temba_insert_system_label(NEW.org_id, _new_label_type, FALSE, 1);
      END IF;
    END IF;

  -- existing broadcast deleted
  ELSIF TG_OP = 'DELETE' THEN
    _old_label_type := temba_broadcast_determine_system_label(OLD);

    IF _old_label_type IS NOT NULL THEN
      PERFORM temba_insert_system_label(OLD.org_id, _old_label_type, FALSE, -1);
    END IF;

  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


-- Trigger procedure to update system labels on channel event changes
CREATE OR REPLACE FUNCTION temba_channelevent_on_change() RETURNS TRIGGER AS $$
BEGIN
  -- new event inserted
  IF TG_OP = 'INSERT' THEN
    -- don't update anything for a non-call event
    IF NOT temba_channelevent_is_call(NEW) THEN
      RETURN NULL;
    END IF;

    PERFORM temba_insert_system_label(NEW.org_id, 'C', FALSE, 1);

  -- existing call updated
  ELSIF TG_OP = 'UPDATE' THEN
    -- don't update anything for a non-call event
    IF NOT temba_channelevent_is_call(NEW) THEN
      RETURN NULL;
    END IF;

  -- existing call deleted
  ELSIF TG_OP = 'DELETE' THEN
    -- don't update anything for a non-call event
    IF NOT temba_channelevent_is_call(OLD) THEN
      RETURN NULL;
    END IF;

    PERFORM temba_insert_system_label(OLD.org_id, 'C', FALSE, -1);

  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Handles deleting flow runs
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_delete() RETURNS TRIGGER AS $$
DECLARE
    p INT;
    _path_json JSONB;
    _path_len INT;
BEGIN
    -- leave activity as is if we're being archived
    IF OLD.delete_reason = 'A' THEN
        RETURN NULL;
    END IF;

    -- nothing to do if path was empty
    IF OLD.path IS NULL OR OLD.path = '[]' THEN RETURN NULL; END IF;

    -- parse path as JSON
    _path_json := OLD.path::json;
    _path_len := jsonb_array_length(_path_json);

    -- decrement node count at last node in this path if this was an active run
    IF OLD.is_active THEN
        PERFORM temba_insert_flownodecount(OLD.flow_id, UUID(_path_json->(_path_len-1)->>'node_uuid'), -1);
    END IF;

    -- for each step in the path, decrement the path count
    p := 1;
    LOOP
        EXIT WHEN p >= _path_len;

        -- it's possible that steps from old flows don't have exit_uuid
        IF (_path_json->(p-1)->'exit_uuid') IS NOT NULL THEN
            PERFORM temba_insert_flowpathcount(
                OLD.flow_id,
                UUID(_path_json->(p-1)->>'exit_uuid'),
                UUID(_path_json->p->>'node_uuid'),
                timestamptz(_path_json->p->>'arrived_on'),
                -1
            );
        END IF;

        p := p + 1;
    END LOOP;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Handles inserting new flow runs
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_insert() RETURNS TRIGGER AS $$
DECLARE
    p INT;
    _path_json JSONB;
    _path_len INT;
BEGIN
    -- nothing to do if path is empty
    IF NEW.path IS NULL OR NEW.path = '[]' THEN RETURN NULL; END IF;

    -- parse path as JSON
    _path_json := NEW.path::json;
    _path_len := jsonb_array_length(_path_json);

    -- increment node count at last node in this path if this is an active run
    IF _path_len > 0 AND NEW.is_active THEN
        PERFORM temba_insert_flownodecount(NEW.flow_id, UUID(_path_json->(_path_len-1)->>'node_uuid'), 1);
    END IF;

    -- for each step in the path, increment the path count, and record a recent run
    p := 1;
    LOOP
        EXIT WHEN p >= _path_len;

        PERFORM temba_insert_flowpathcount(
            NEW.flow_id,
            UUID(_path_json->(p-1)->>'exit_uuid'),
            UUID(_path_json->p->>'node_uuid'),
            timestamptz(_path_json->p->>'arrived_on'),
            1
        );
        PERFORM temba_insert_flowpathrecentrun(
            UUID(_path_json->(p-1)->>'exit_uuid'),
            UUID(_path_json->(p-1)->>'uuid'),
            UUID(_path_json->p->>'node_uuid'),
            UUID(_path_json->p->>'uuid'),
            NEW.id,
            timestamptz(_path_json->p->>'arrived_on')
        );

        p := p + 1;
    END LOOP;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Handles changes relating to a flow run's path
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_flowrun_path_change() RETURNS TRIGGER AS $$
DECLARE
  p INT;
  _old_path_json JSONB;
  _new_path_json JSONB;
  _old_path_len INT;
  _new_path_len INT;
  _old_last_step_uuid TEXT;
BEGIN
    -- restrict changes
    IF NEW.is_active AND NOT OLD.is_active THEN RAISE EXCEPTION 'Cannot re-activate an inactive flow run'; END IF;

    _old_path_json := COALESCE(OLD.path, '[]')::jsonb;
    _new_path_json := COALESCE(NEW.path, '[]')::jsonb;
    _old_path_len := jsonb_array_length(_old_path_json);
    _new_path_len := jsonb_array_length(_new_path_json);

    -- we don't support rewinding run paths, so the new path must be longer than the old
    IF _new_path_len < _old_path_len THEN RAISE EXCEPTION 'Cannot rewind a flow run path'; END IF;

    -- update the node counts
    IF _old_path_len > 0 AND OLD.is_active THEN
        PERFORM temba_insert_flownodecount(OLD.flow_id, UUID(_old_path_json->(_old_path_len-1)->>'node_uuid'), -1);
    END IF;

    IF _new_path_len > 0 AND NEW.is_active THEN
        PERFORM temba_insert_flownodecount(NEW.flow_id, UUID(_new_path_json->(_new_path_len-1)->>'node_uuid'), 1);
    END IF;

    -- if we have an old path, find its last step in the new path, and that will be our starting point
    IF _old_path_len > 1 THEN
        _old_last_step_uuid := _old_path_json->(_old_path_len-1)->>'uuid';

        -- old and new paths end with same step so path activity doesn't change
        IF _old_last_step_uuid = _new_path_json->(_new_path_len-1)->>'uuid' THEN
            RETURN NULL;
        END IF;

        p := _new_path_len - 1;
        LOOP
            EXIT WHEN p = 1 OR _new_path_json->(p-1)->>'uuid' = _old_last_step_uuid;
            p := p - 1;
        END LOOP;
    ELSE
        p := 1;
    END IF;

    LOOP
      EXIT WHEN p >= _new_path_len;
      PERFORM temba_insert_flowpathcount(
          NEW.flow_id,
          UUID(_new_path_json->(p-1)->>'exit_uuid'),
          UUID(_new_path_json->p->>'node_uuid'),
          timestamptz(_new_path_json->p->>'arrived_on'),
          1
      );
      PERFORM temba_insert_flowpathrecentrun(
          UUID(_new_path_json->(p-1)->>'exit_uuid'),
          UUID(_new_path_json->(p-1)->>'uuid'),
          UUID(_new_path_json->p->>'node_uuid'),
          UUID(_new_path_json->p->>'uuid'),
          NEW.id,
          timestamptz(_new_path_json->p->>'arrived_on')
      );
      p := p + 1;
    END LOOP;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Trigger procedure to update user and system labels on column changes
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_msg_on_change() RETURNS TRIGGER AS $$
DECLARE
  _new_label_type CHAR(1);
  _old_label_type CHAR(1);
BEGIN
  IF TG_OP IN ('INSERT', 'UPDATE') THEN
    -- prevent illegal message states
    IF NEW.direction = 'I' AND NEW.status NOT IN ('P', 'H') THEN
      RAISE EXCEPTION 'Incoming messages can only be PENDING or HANDLED';
    END IF;
    IF NEW.direction = 'O' AND NEW.visibility = 'A' THEN
      RAISE EXCEPTION 'Outgoing messages cannot be archived';
    END IF;
  END IF;

  -- new message inserted
  IF TG_OP = 'INSERT' THEN
    _new_label_type := temba_msg_determine_system_label(NEW);
    IF _new_label_type IS NOT NULL THEN
      PERFORM temba_insert_system_label(NEW.org_id, _new_label_type, FALSE, 1);
    END IF;

    IF NEW.broadcast_id IS NOT NULL THEN
      PERFORM temba_insert_broadcastmsgcount(NEW.broadcast_id, 1);
    END IF;

  -- existing message updated
  ELSIF TG_OP = 'UPDATE' THEN
    _old_label_type := temba_msg_determine_system_label(OLD);
    _new_label_type := temba_msg_determine_system_label(NEW);

    IF _old_label_type IS DISTINCT FROM _new_label_type THEN
      IF _old_label_type IS NOT NULL THEN
        PERFORM temba_insert_system_label(OLD.org_id, _old_label_type, FALSE, -1);
      END IF;
      IF _new_label_type IS NOT NULL THEN
        PERFORM temba_insert_system_label(NEW.org_id, _new_label_type, FALSE, 1);
      END IF;
    END IF;

    -- is being archived or deleted (i.e. no longer included for user labels)
    IF OLD.visibility = 'V' AND NEW.visibility != 'V' THEN
      PERFORM temba_insert_message_label_counts(NEW.id, FALSE, -1);
    END IF;

    -- is being restored (i.e. now included for user labels)
    IF OLD.visibility != 'V' AND NEW.visibility = 'V' THEN
      PERFORM temba_insert_message_label_counts(NEW.id, FALSE, 1);
    END IF;

    -- update our broadcast msg count if it changed
    IF NEW.broadcast_id IS DISTINCT FROM OLD.broadcast_id THEN
      PERFORM temba_insert_broadcastmsgcount(OLD.broadcast_id, -1);
      PERFORM temba_insert_broadcastmsgcount(NEW.broadcast_id, 1);
    END IF;

  -- existing message deleted
  ELSIF TG_OP = 'DELETE' THEN
    _old_label_type := temba_msg_determine_system_label(OLD);

    IF _old_label_type IS NOT NULL THEN
      IF OLD.delete_reason = 'A' THEN
        PERFORM temba_insert_system_label(OLD.org_id, _old_label_type, FALSE, -1);
        PERFORM temba_insert_system_label(OLD.org_id, _old_label_type, TRUE, 1);
      ELSE
        PERFORM temba_insert_system_label(OLD.org_id, _old_label_type, FALSE, -1);
      END IF;

    END IF;

    IF OLD.broadcast_id IS NOT NULL AND OLD.delete_reason != 'A' THEN
      PERFORM temba_insert_broadcastmsgcount(OLD.broadcast_id, -1);
    END IF;

  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Manages keeping track of the # of messages sent and received by a channel
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_update_channelcount() RETURNS TRIGGER AS $$
BEGIN
  -- Message being updated
  IF TG_OP = 'INSERT' THEN
    -- Return if there is no channel on this message
    IF NEW.channel_id IS NULL THEN
      RETURN NULL;
    END IF;

    -- If this is an incoming message, without message type, then increment that count
    IF NEW.direction = 'I' THEN
      -- This is a voice message, increment that count
      IF NEW.msg_type = 'V' THEN
        PERFORM temba_insert_channelcount(NEW.channel_id, 'IV', NEW.created_on::date, 1);
      -- Otherwise, this is a normal message
      ELSE
        PERFORM temba_insert_channelcount(NEW.channel_id, 'IM', NEW.created_on::date, 1);
      END IF;

    -- This is an outgoing message
    ELSIF NEW.direction = 'O' THEN
      -- This is a voice message, increment that count
      IF NEW.msg_type = 'V' THEN
        PERFORM temba_insert_channelcount(NEW.channel_id, 'OV', NEW.created_on::date, 1);
      -- Otherwise, this is a normal message
      ELSE
        PERFORM temba_insert_channelcount(NEW.channel_id, 'OM', NEW.created_on::date, 1);
      END IF;

    END IF;

  -- Assert that updates aren't happening that we don't approve of
  ELSIF TG_OP = 'UPDATE' THEN
    -- If the direction is changing, blow up
    IF NEW.direction <> OLD.direction THEN
      RAISE EXCEPTION 'Cannot change direction on messages';
    END IF;

    -- Cannot move from IVR to Text, or IVR to Text
    IF (OLD.msg_type <> 'V' AND NEW.msg_type = 'V') OR (OLD.msg_type = 'V' AND NEW.msg_type <> 'V') THEN
      RAISE EXCEPTION 'Cannot change a message from voice to something else or vice versa';
    END IF;

    -- Cannot change created_on
    IF NEW.created_on <> OLD.created_on THEN
      RAISE EXCEPTION 'Cannot change created_on on messages';
    END IF;

  -- Clean up counts when we are doing a real delete
  ELSIF TG_OP = 'DELETE' THEN
    IF OLD.delete_reason IS NULL THEN
      -- If this is an incoming message, without message type, then increment that count
      IF OLD.direction = 'I' THEN
        -- This is a voice message, decrement that count
        IF OLD.msg_type = 'V' THEN
          PERFORM temba_insert_channelcount(OLD.channel_id, 'IV', OLD.created_on::date, -1);
        -- Otherwise, this is a normal message
        ELSE
          PERFORM temba_insert_channelcount(OLD.channel_id, 'IM', OLD.created_on::date, -1);
        END IF;

      -- This is an outgoing message
      ELSIF OLD.direction = 'O' THEN
        -- This is a voice message, decrement that count
        IF OLD.msg_type = 'V' THEN
          PERFORM temba_insert_channelcount(OLD.channel_id, 'OV', OLD.created_on::date, -1);
        -- Otherwise, this is a normal message
        ELSE
          PERFORM temba_insert_channelcount(OLD.channel_id, 'OM', OLD.created_on::date, -1);
        END IF;
      END IF;
    END IF;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION temba_update_flowcategorycount() RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    IF OLD.delete_reason = 'A' THEN
      RETURN NULL;
    END IF;

    EXECUTE temba_update_category_counts(OLD.flow_id, NULL, OLD.results::json);

    RETURN NULL;
  END IF;

  IF TG_OP = 'INSERT' THEN
    EXECUTE temba_update_category_counts(NEW.flow_id, NEW.results::json, NULL);

  ELSIF TG_OP = 'UPDATE' THEN
    -- use string comparison to check for no-change case
    IF NEW.results = OLD.results THEN RETURN NULL; END IF;

    EXECUTE temba_update_category_counts(NEW.flow_id, NEW.results::json, OLD.results::json);
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Increments or decrements our counts for each exit type
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION temba_update_flowruncount() RETURNS TRIGGER AS $$
BEGIN
  -- FlowRun being added
  IF TG_OP = 'INSERT' THEN
    -- Increment appropriate type
    PERFORM temba_insert_flowruncount(NEW.flow_id, NEW.exit_type, 1);

  -- FlowRun being removed
  ELSIF TG_OP = 'DELETE' THEN
     -- If we're being archived, don't change stats
     IF OLD.delete_reason = 'A' THEN
       RETURN NULL;
     END IF;

    PERFORM temba_insert_flowruncount(OLD.flow_id, OLD.exit_type, -1);

  -- Updating exit type
  ELSIF TG_OP = 'UPDATE' THEN
    PERFORM temba_insert_flowruncount(OLD.flow_id, OLD.exit_type, -1);
    PERFORM temba_insert_flowruncount(NEW.flow_id, NEW.exit_type, 1);
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Trigger procedure to update contact system groups on column changes
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_contact_system_groups() RETURNS TRIGGER AS $$
BEGIN
  -- new contact added
  IF TG_OP = 'INSERT' AND NEW.is_active THEN
    IF NEW.is_blocked THEN
      PERFORM contact_toggle_system_group(NEW, 'B', true);
    END IF;

    IF NEW.is_stopped THEN
      PERFORM contact_toggle_system_group(NEW, 'S', true);
    END IF;

    IF NOT NEW.is_stopped AND NOT NEW.is_blocked THEN
      PERFORM contact_toggle_system_group(NEW, 'A', true);
    END IF;
  END IF;

  -- existing contact updated
  IF TG_OP = 'UPDATE' THEN
    -- do nothing for inactive contacts
    IF NOT OLD.is_active AND NOT NEW.is_active THEN
      RETURN NULL;
    END IF;

    -- is being blocked
    IF NOT OLD.is_blocked AND NEW.is_blocked THEN
      PERFORM contact_toggle_system_group(NEW, 'B', true);
      PERFORM contact_toggle_system_group(NEW, 'A', false);
    END IF;

    -- is being unblocked
    IF OLD.is_blocked AND NOT NEW.is_blocked THEN
      PERFORM contact_toggle_system_group(NEW, 'B', false);
      IF NOT NEW.is_stopped THEN
        PERFORM contact_toggle_system_group(NEW, 'A', true);
      END IF;
    END IF;

    -- they stopped themselves
    IF NOT OLD.is_stopped AND NEW.is_stopped THEN
      PERFORM contact_toggle_system_group(NEW, 'S', true);
      PERFORM contact_toggle_system_group(NEW, 'A', false);
    END IF;

    -- they opted back in
    IF OLD.is_stopped AND NOT NEW.is_stopped THEN
    PERFORM contact_toggle_system_group(NEW, 'S', false);
      IF NOT NEW.is_blocked THEN
        PERFORM contact_toggle_system_group(NEW, 'A', true);
      END IF;
    END IF;

    -- is being released
    IF OLD.is_active AND NOT NEW.is_active THEN
      PERFORM contact_toggle_system_group(NEW, 'A', false);
      PERFORM contact_toggle_system_group(NEW, 'B', false);
      PERFORM contact_toggle_system_group(NEW, 'S', false);
    END IF;

    -- is being unreleased
    IF NOT OLD.is_active AND NEW.is_active THEN
      IF NEW.is_blocked THEN
        PERFORM contact_toggle_system_group(NEW, 'B', true);
      END IF;

      IF NEW.is_stopped THEN
        PERFORM contact_toggle_system_group(NEW, 'S', true);
      END IF;

      IF NOT NEW.is_stopped AND NOT NEW.is_blocked THEN
        PERFORM contact_toggle_system_group(NEW, 'A', true);
      END IF;
    END IF;

  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------
-- Trigger procedure to update group count
----------------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_group_count() RETURNS TRIGGER AS $$
BEGIN
  -- contact being added to group
  IF TG_OP = 'INSERT' THEN
    INSERT INTO contacts_contactgroupcount("group_id", "count", "is_squashed") VALUES(NEW.contactgroup_id, 1, FALSE);

  -- contact being removed from a group
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO contacts_contactgroupcount("group_id", "count", "is_squashed") VALUES(OLD.contactgroup_id, -1, FALSE);

  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


DROP FUNCTION temba_flows_contact_is_test(_contact_id INT);
DROP FUNCTION temba_contact_is_test(_contact_id INT);
"""


class Migration(migrations.Migration):

    dependencies = [
        ("channels", "0116_auto_20190131_2013"),
        ("contacts", "0094_remove_test_contacts"),
        ("flows", "0194_auto_20190204_1835"),
        ("msgs", "0130_auto_20181128_1226"),
    ]

    operations = [migrations.RunSQL(SQL)]
